# Guide — Building a Streamable HTTP MCP Server in Rust with rmcp (macro‑based)

This guide shows how to build a **Streamable HTTP** MCP server in Rust using the official `rmcp` crate and its **macros** (`#[tool]`, `#[tool_router]`). We’ll define a simple tool, implement the minimal server behavior, and expose it over **Streamable HTTP** using an Axum/Hyper server.

> Works with `rmcp` 0.6.x. The code below follows the patterns used in the crate docs and examples.

---

## 1) Why Streamable HTTP?

MCP defines multiple transports. In Rust `rmcp` you’ll most commonly use:

- **stdio**: great for local, embedded servers.
- **SSE (HTTP+SSE)**: legacy/deprecated transport kept for compatibility.
- **Streamable HTTP**: the modern HTTP transport that supports streaming request/response bodies and server‑side events over a single HTTP endpoint. This is what we implement here.

---

## 2) Project setup

**Cargo.toml** (key dependencies & features):

```toml
[package]
name = "mcp-counter"
version = "0.1.0"
edition = "2021"

[dependencies]
# Core MCP crate + server & Streamable HTTP features
rmcp = { version = "0.6", features = [
  "server",
  "transport-streamable-http-server",
  "transport-streamable-http-server-session" # stateful session manager
] }

# Runtime + HTTP stack
tokio = { version = "1", features = ["rt-multi-thread", "macros"] }
axum = "0.8"
hyper = { version = "1" }

# Nice-to-haves
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# For structured tool I/O (if you return JSON objects from tools)
serde = { version = "1", features = ["derive"] }
schemars = "1"
```

---

## 3) Define tools with rmcp macros

`rmcp`’s attribute macros let you write tool handlers as regular async methods. The `#[tool_router]` macro generates the routing glue, and **the struct must contain a `tool_router: ToolRouter<Self>` field**.

```rust
use std::sync::Arc;
use tokio::sync::Mutex;

use rmcp::{
    ErrorData as McpError,
    model::{CallToolResult, Content},
    handler::server::tool::ToolRouter,
    tool, tool_router,
};

#[derive(Clone)]
pub struct Counter {
    counter: Arc<Mutex<i32>>,         // shared mutable state
    tool_router: ToolRouter<Self>,    // required by #[tool_router]
}

#[tool_router]
impl Counter {
    pub fn new() -> Self {
        Self {
            counter: Arc::new(Mutex::new(0)),
            tool_router: Self::tool_router(), // generated by the macro
        }
    }

    /// Increments the counter and returns the new value as text.
    #[tool(description = "Increment the counter by 1")]
    pub async fn increment(&self) -> Result<CallToolResult, McpError> {
        let mut n = self.counter.lock().await;
        *n += 1;
        Ok(CallToolResult::success(vec![Content::text(n.to_string())]))
    }
}
```

### (Optional) Structured JSON output
If you want tools to return **typed JSON** with a schema, return `rmcp::handler::server::wrapper::Json<T>` where `T: Serialize + DeserializeOwned + JsonSchema`.

```rust
use rmcp::{schemars::JsonSchema, serde::{Deserialize, Serialize}};
use rmcp::handler::server::wrapper::Json;
use rmcp::model::Parameters;

#[derive(Serialize, Deserialize, JsonSchema)]
struct CalculationRequest { a: i32, b: i32, operation: String }

#[derive(Serialize, Deserialize, JsonSchema)]
struct CalculationResult { result: i32, operation: String }

#[tool(name = "calculate", description = "Perform a calculation")]
pub async fn calculate(
    &self,
    params: Parameters<CalculationRequest>,
) -> Result<Json<CalculationResult>, String> {
    let r = match params.0.operation.as_str() {
        "add" => params.0.a + params.0.b,
        "multiply" => params.0.a * params.0.b,
        other => return Err(format!("unknown op: {other}")),
    };
    Ok(Json(CalculationResult { result: r, operation: params.0.operation }))
}
```

---

## 4) Minimal server behavior (`ServerHandler`)

You can implement the MCP server lifecycle by implementing `rmcp::ServerHandler` for your type. For a minimal server, overriding `get_info` is usually enough because the default trait methods handle the standard operations and the tool router exposes your tools.

```rust
use rmcp::handler::server::{ServerHandler, ServerInfo};

impl ServerHandler for Counter {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            name: "mcp-counter".into(),
            version: env!("CARGO_PKG_VERSION").into(),
        }
    }
}
```

---

## 5) Expose **Streamable HTTP** with Axum/Hyper

`rmcp` provides a Tower service for Streamable HTTP that you can mount on any web stack that speaks Tower/Hyper. The **single endpoint** (e.g. `/mcp`) will accept:

- `POST /mcp` for JSON‑RPC requests (initialize, list_tools, call_tool, …)
- `GET /mcp` to open the server‑side event stream (progress, prompts, streaming tokens, etc.)
- `DELETE /mcp` to terminate a session

### Code

```rust
use axum::Router;
use rmcp::transport::streamable_http_server::tower::{
    StreamableHttpServerConfig, StreamableHttpService,
};
use std::time::Duration;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // logging
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .init();

    // Build the Streamable HTTP Tower service
    let svc = StreamableHttpService::new(
        || Ok(Counter::new()),               // per-connection/server factory
        Default::default(),                   // in-memory session manager
        StreamableHttpServerConfig {
            // Send comment frames periodically to keep SSE alive (reverse proxies)
            sse_keep_alive: Some(Duration::from_secs(15)),
            // Require stateful sessions via `Mcp-Session-Id` header
            stateful_mode: true,
        },
    );

    // Mount at /mcp (one path for POST/GET/DELETE)
    let app = Router::new().route_service("/mcp", svc);

    // Run HTTP server
    let listener = tokio::net::TcpListener::bind(("0.0.0.0", 8080)).await?;
    tracing::info!("listening on http://localhost:8080/mcp");
    axum::serve(listener, app).await?;
    Ok(())
}
```

> You can add tower layers (auth, logging, CORS) around `svc` or around the `Router` as needed.

---

## 6) Try it with `curl`

1) **Initialize** (creates a session; the server replies with headers including `Mcp-Session-Id`):

```bash
curl -i -X POST http://localhost:8080/mcp \
  -H 'Content-Type: application/json' \
  -d '{
    "jsonrpc":"2.0",
    "id":"1",
    "method":"initialize",
    "params":{
      "protocolVersion":"2025-03-26",
      "capabilities":{},
      "clientInfo":{"name":"curl","version":"0"}
    }
  }'
```

2) **List tools** (use the `Mcp-Session-Id` value from the previous response):

```bash
curl -s -X POST http://localhost:8080/mcp \
  -H "Mcp-Session-Id: <paste-session-id>" \
  -H 'Content-Type: application/json' \
  -d '{"jsonrpc":"2.0","id":"2","method":"tools/list","params":{}}'
```

3) **Call a tool** (our `increment` tool):

```bash
curl -s -X POST http://localhost:8080/mcp \
  -H "Mcp-Session-Id: <paste-session-id>" \
  -H 'Content-Type: application/json' \
  -d '{"jsonrpc":"2.0","id":"3","method":"tools/call","params":{"name":"increment"}}'
```

4) **Open the server event stream** (progress, streaming tokens, server‑initiated requests):

```bash
curl -N -X GET http://localhost:8080/mcp \
  -H "Accept: text/event-stream" \
  -H "Mcp-Session-Id: <paste-session-id>"
```

5) **Terminate the session**:

```bash
curl -i -X DELETE http://localhost:8080/mcp \
  -H "Mcp-Session-Id: <paste-session-id>"
```

---

## 7) Notes & gotchas

- **`tool_router` field is required** on your server struct; initialize it via `Self::tool_router()` inside the `#[tool_router]` impl.
- If you return **structured JSON**, wrap the output type with `rmcp::handler::server::wrapper::Json<T>` and derive `Serialize`, `Deserialize`, `JsonSchema` for `T`.
- **Sessions**: with `stateful_mode: true`, clients must include `Mcp-Session-Id` for all requests after `initialize`. Missing/expired IDs should be handled as `400/404` according to the spec.
- **SSE keep‑alive**: set `sse_keep_alive` to periodically write comment frames (`: keepalive\n\n`) so load‑balancers/reverse proxies don’t drop idle connections.
- **CORS**: if you expose this on the public web, add a CORS layer around the Axum router.
- **Auth**: Streamable HTTP doesn’t prescribe auth; add your own (e.g., a Tower layer that checks a bearer token/header) and pass through validated requests to the MCP service.

---

## 8) Testing & tooling

- **MCP Inspector**: configure it to connect to your Streamable HTTP endpoint directly, or point it at a proxy (e.g., `mcp-remote`) if your client only supports stdio.
- **Integration tests**: you can drive the server with HTTP requests using Hyper or `reqwest`, verifying lifecycle (`initialize` → tool calls → `DELETE`).

---

## 9) Extending this skeleton

- Add more tools (files, prompts, resources) using the corresponding `#[tool]`, `#[prompt]`, and router macros.
- Implement custom progress streaming from long‑running tools by sending progress notifications; the stream will surface via the GET event stream.
- Swap Axum for another Tower‑compatible web framework or run the service directly with Hyper.

---

## 10) Complete example (single file)

```rust
use std::sync::Arc;
use tokio::sync::Mutex;
use std::time::Duration;

use axum::Router;
use rmcp::{
    ErrorData as McpError,
    model::{CallToolResult, Content},
    handler::server::{ServerHandler, ServerInfo},
    handler::server::tool::ToolRouter,
    tool, tool_router,
    transport::streamable_http_server::tower::{
        StreamableHttpServerConfig, StreamableHttpService,
    },
};

#[derive(Clone)]
struct Counter {
    counter: Arc<Mutex<i32>>,
    tool_router: ToolRouter<Self>,
}

#[tool_router]
impl Counter {
    fn new() -> Self {
        Self { counter: Arc::new(Mutex::new(0)), tool_router: Self::tool_router() }
    }

    #[tool(description = "Increment the counter by 1")]
    async fn increment(&self) -> Result<CallToolResult, McpError> {
        let mut n = self.counter.lock().await;
        *n += 1;
        Ok(CallToolResult::success(vec![Content::text(n.to_string())]))
    }
}

impl ServerHandler for Counter {
    fn get_info(&self) -> ServerInfo {
        ServerInfo { name: "mcp-counter".into(), version: env!("CARGO_PKG_VERSION").into() }
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt().with_env_filter("info").init();

    let svc = StreamableHttpService::new(
        || Ok(Counter::new()),
        Default::default(),
        StreamableHttpServerConfig { sse_keep_alive: Some(Duration::from_secs(15)), stateful_mode: true },
    );

    let app = Router::new().route_service("/mcp", svc);

    let listener = tokio::net::TcpListener::bind(("0.0.0.0", 8080)).await?;
    tracing::info!("listening on http://localhost:8080/mcp");
    axum::serve(listener, app).await?;
    Ok(())
}
```

---

### That’s it
You now have a minimal, macro‑based **Streamable HTTP** MCP server in Rust. Add tools, wrap with middleware, deploy behind a reverse proxy, and plug it into clients like Claude Desktop or IDEs that speak MCP.

