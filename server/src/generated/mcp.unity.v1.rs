// This file is @generated by prost-build.
/// Import/Export operations for Unity assets
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImportAssetRequest {
    #[prost(string, repeated, tag = "1")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "2")]
    pub recursive: bool,
    #[prost(bool, tag = "3")]
    pub auto_refresh: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImportAssetResult {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub guid: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub ok: bool,
    #[prost(string, tag = "4")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportAssetResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<ImportAssetResult>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MoveAssetRequest {
    #[prost(string, tag = "1")]
    pub from_path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub to_path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MoveAssetResponse {
    #[prost(bool, tag = "1")]
    pub ok: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub new_guid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteAssetRequest {
    #[prost(string, repeated, tag = "1")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "2")]
    pub soft: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteAssetResponse {
    #[prost(string, repeated, tag = "1")]
    pub deleted: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub failed: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RefreshRequest {
    #[prost(bool, tag = "1")]
    pub force: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RefreshResponse {
    #[prost(bool, tag = "1")]
    pub ok: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GuidToPathRequest {
    #[prost(string, repeated, tag = "1")]
    pub guids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuidToPathResponse {
    #[prost(map = "string, string", tag = "1")]
    pub map: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PathToGuidRequest {
    #[prost(string, repeated, tag = "1")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PathToGuidResponse {
    #[prost(map = "string, string", tag = "1")]
    pub map: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AssetsRequest {
    #[prost(oneof = "assets_request::Payload", tags = "1, 2, 3, 4, 5, 6")]
    pub payload: ::core::option::Option<assets_request::Payload>,
}
/// Nested message and enum types in `AssetsRequest`.
pub mod assets_request {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        Import(super::ImportAssetRequest),
        #[prost(message, tag = "2")]
        Move(super::MoveAssetRequest),
        #[prost(message, tag = "3")]
        Delete(super::DeleteAssetRequest),
        #[prost(message, tag = "4")]
        Refresh(super::RefreshRequest),
        #[prost(message, tag = "5")]
        G2p(super::GuidToPathRequest),
        #[prost(message, tag = "6")]
        P2g(super::PathToGuidRequest),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetsResponse {
    /// 0=OK, 2=INVALID_ARGUMENT, 5=NOT_FOUND, 13=INTERNAL
    #[prost(int32, tag = "1")]
    pub status_code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(oneof = "assets_response::Payload", tags = "10, 11, 12, 13, 14, 15")]
    pub payload: ::core::option::Option<assets_response::Payload>,
}
/// Nested message and enum types in `AssetsResponse`.
pub mod assets_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "10")]
        Import(super::ImportAssetResponse),
        #[prost(message, tag = "11")]
        Move(super::MoveAssetResponse),
        #[prost(message, tag = "12")]
        Delete(super::DeleteAssetResponse),
        #[prost(message, tag = "13")]
        Refresh(super::RefreshResponse),
        #[prost(message, tag = "14")]
        G2p(super::GuidToPathResponse),
        #[prost(message, tag = "15")]
        P2g(super::PathToGuidResponse),
    }
}
/// Architecture or variant knobs (optional where relevant)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuildVariants {
    /// e.g., "x86_64", "arm64" (macOS), "universal"
    #[prost(string, tag = "1")]
    pub architecture: ::prost::alloc::string::String,
    /// e.g., \["arm64-v8a","armeabi-v7a"\] (Android)
    #[prost(string, repeated, tag = "2")]
    pub abis: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Development build flag
    #[prost(bool, tag = "3")]
    pub development: bool,
    /// Force IL2CPP if applicable
    #[prost(bool, tag = "4")]
    pub il2cpp: bool,
    /// Strip build
    #[prost(bool, tag = "5")]
    pub strip_symbols: bool,
}
/// Player build request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildPlayerRequest {
    #[prost(enumeration = "BuildPlatform", tag = "1")]
    pub platform: i32,
    /// absolute or project-relative path
    #[prost(string, tag = "2")]
    pub output_path: ::prost::alloc::string::String,
    /// project-relative e.g., "Assets/Scenes/Main.unity"
    #[prost(string, repeated, tag = "3")]
    pub scenes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// arch/abi/dev flags
    #[prost(message, optional, tag = "4")]
    pub variants: ::core::option::Option<BuildVariants>,
    /// scripting define symbols per group
    #[prost(map = "string, string", tag = "5")]
    pub define_symbols: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Player build response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuildPlayerResponse {
    /// 0 OK; nonzero = failure
    #[prost(int32, tag = "1")]
    pub status_code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// final file/dir
    #[prost(string, tag = "3")]
    pub output_path: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub build_time_ms: u64,
    /// if available from report
    #[prost(uint64, tag = "5")]
    pub size_bytes: u64,
    #[prost(string, repeated, tag = "6")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// AssetBundles build request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuildAssetBundlesRequest {
    /// absolute or project-relative
    #[prost(string, tag = "1")]
    pub output_directory: ::prost::alloc::string::String,
    /// BuildAssetBundleOptions.DeterministicAssetBundle
    #[prost(bool, tag = "2")]
    pub deterministic: bool,
    /// ChunkBasedCompression
    #[prost(bool, tag = "3")]
    pub chunk_based: bool,
    /// ForceRebuildAssetBundle
    #[prost(bool, tag = "4")]
    pub force_rebuild: bool,
}
/// AssetBundles build response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuildAssetBundlesResponse {
    #[prost(int32, tag = "1")]
    pub status_code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub output_directory: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub build_time_ms: u64,
}
/// Unified build request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildRequest {
    #[prost(oneof = "build_request::Payload", tags = "1, 2")]
    pub payload: ::core::option::Option<build_request::Payload>,
}
/// Nested message and enum types in `BuildRequest`.
pub mod build_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        Player(super::BuildPlayerRequest),
        #[prost(message, tag = "2")]
        Bundles(super::BuildAssetBundlesRequest),
    }
}
/// Unified build response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuildResponse {
    #[prost(oneof = "build_response::Payload", tags = "1, 2")]
    pub payload: ::core::option::Option<build_response::Payload>,
}
/// Nested message and enum types in `BuildResponse`.
pub mod build_response {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        Player(super::BuildPlayerResponse),
        #[prost(message, tag = "2")]
        Bundles(super::BuildAssetBundlesResponse),
    }
}
/// Supported platforms (subset; extend as needed)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BuildPlatform {
    BpUnspecified = 0,
    BpStandaloneWindows64 = 1,
    /// macOS
    BpStandaloneOsx = 2,
    BpStandaloneLinux64 = 3,
    BpAndroid = 10,
    BpIos = 11,
}
impl BuildPlatform {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BpUnspecified => "BP_UNSPECIFIED",
            Self::BpStandaloneWindows64 => "BP_STANDALONE_WINDOWS64",
            Self::BpStandaloneOsx => "BP_STANDALONE_OSX",
            Self::BpStandaloneLinux64 => "BP_STANDALONE_LINUX64",
            Self::BpAndroid => "BP_ANDROID",
            Self::BpIos => "BP_IOS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BP_UNSPECIFIED" => Some(Self::BpUnspecified),
            "BP_STANDALONE_WINDOWS64" => Some(Self::BpStandaloneWindows64),
            "BP_STANDALONE_OSX" => Some(Self::BpStandaloneOsx),
            "BP_STANDALONE_LINUX64" => Some(Self::BpStandaloneLinux64),
            "BP_ANDROID" => Some(Self::BpAndroid),
            "BP_IOS" => Some(Self::BpIos),
            _ => None,
        }
    }
}
/// Generic empty placeholder to avoid google.protobuf.Empty at L0.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Empty {}
/// Minimal operation reference for streaming/event demos.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationRef {
    /// opaque identifier
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HealthRequest {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HealthResponse {
    #[prost(bool, tag = "1")]
    pub ready: bool,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// e.g., "OK" - kept for backward compatibility
    #[prost(string, tag = "3")]
    pub status: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPlayModeResponse {
    #[prost(bool, tag = "1")]
    pub is_playing: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetPlayModeRequest {
    #[prost(bool, tag = "1")]
    pub play: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetPlayModeResponse {
    #[prost(bool, tag = "1")]
    pub applied: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LogEvent {
    /// sender clock
    #[prost(int64, tag = "1")]
    pub monotonic_ts_ns: i64,
    #[prost(enumeration = "log_event::Level", tag = "2")]
    pub level: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    /// e.g., "Unity", "Build", "Assets"
    #[prost(string, tag = "4")]
    pub category: ::prost::alloc::string::String,
    /// optional, compacted
    #[prost(string, tag = "5")]
    pub stack_trace: ::prost::alloc::string::String,
}
/// Nested message and enum types in `LogEvent`.
pub mod log_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Level {
        Trace = 0,
        Debug = 1,
        Info = 2,
        Warn = 3,
        Error = 4,
    }
    impl Level {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Trace => "TRACE",
                Self::Debug => "DEBUG",
                Self::Info => "INFO",
                Self::Warn => "WARN",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRACE" => Some(Self::Trace),
                "DEBUG" => Some(Self::Debug),
                "INFO" => Some(Self::Info),
                "WARN" => Some(Self::Warn),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationEvent {
    /// unique per operation
    #[prost(string, tag = "1")]
    pub op_id: ::prost::alloc::string::String,
    #[prost(enumeration = "operation_event::Kind", tag = "2")]
    pub kind: i32,
    /// 0..100, for PROGRESS/COMPLETE
    #[prost(int32, tag = "3")]
    pub progress: i32,
    /// 0=OK; nonzero=error codes on COMPLETE
    #[prost(int32, tag = "4")]
    pub code: i32,
    /// short human message
    #[prost(string, tag = "5")]
    pub message: ::prost::alloc::string::String,
    /// optional structured data
    #[prost(string, tag = "6")]
    pub payload_json: ::prost::alloc::string::String,
}
/// Nested message and enum types in `OperationEvent`.
pub mod operation_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        Start = 0,
        Progress = 1,
        Complete = 2,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Start => "START",
                Self::Progress => "PROGRESS",
                Self::Complete => "COMPLETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "START" => Some(Self::Start),
                "PROGRESS" => Some(Self::Progress),
                "COMPLETE" => Some(Self::Complete),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationGetRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationGetResponse {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub state: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationCancelRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationCancelResponse {
    #[prost(bool, tag = "1")]
    pub accepted: bool,
}
/// Top-level envelope for all IPC messages
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpcEnvelope {
    /// Empty for handshake messages
    #[prost(string, tag = "1")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(oneof = "ipc_envelope::Kind", tags = "2, 3, 4")]
    pub kind: ::core::option::Option<ipc_envelope::Kind>,
}
/// Nested message and enum types in `IpcEnvelope`.
pub mod ipc_envelope {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "2")]
        Request(super::IpcRequest),
        #[prost(message, tag = "3")]
        Response(super::IpcResponse),
        #[prost(message, tag = "4")]
        Event(super::IpcEvent),
    }
}
/// Request message with typed payloads
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpcRequest {
    #[prost(oneof = "ipc_request::Payload", tags = "1, 10, 11, 20, 30, 40, 41")]
    pub payload: ::core::option::Option<ipc_request::Payload>,
}
/// Nested message and enum types in `IpcRequest`.
pub mod ipc_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// Health check
        #[prost(message, tag = "1")]
        Health(super::HealthRequest),
        /// Editor control
        #[prost(message, tag = "10")]
        GetPlayMode(super::Empty),
        #[prost(message, tag = "11")]
        SetPlayMode(super::SetPlayModeRequest),
        /// Assets
        #[prost(message, tag = "20")]
        Assets(super::AssetsRequest),
        /// Build
        #[prost(message, tag = "30")]
        Build(super::BuildRequest),
        /// Operations
        #[prost(message, tag = "40")]
        OperationGet(super::OperationGetRequest),
        #[prost(message, tag = "41")]
        OperationCancel(super::OperationCancelRequest),
    }
}
/// Response message with typed payloads
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpcResponse {
    /// Matches the request correlation_id
    #[prost(string, tag = "1")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(oneof = "ipc_response::Payload", tags = "2, 10, 11, 20, 30, 40, 41")]
    pub payload: ::core::option::Option<ipc_response::Payload>,
}
/// Nested message and enum types in `IpcResponse`.
pub mod ipc_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// Health check
        #[prost(message, tag = "2")]
        Health(super::HealthResponse),
        /// Editor control
        #[prost(message, tag = "10")]
        GetPlayMode(super::GetPlayModeResponse),
        #[prost(message, tag = "11")]
        SetPlayMode(super::SetPlayModeResponse),
        /// Assets
        #[prost(message, tag = "20")]
        Assets(super::AssetsResponse),
        /// Build
        #[prost(message, tag = "30")]
        Build(super::BuildResponse),
        /// Operations
        #[prost(message, tag = "40")]
        OperationGet(super::OperationGetResponse),
        #[prost(message, tag = "41")]
        OperationCancel(super::OperationCancelResponse),
    }
}
/// Event message for server-to-client notifications
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IpcEvent {
    #[prost(int64, tag = "1")]
    pub monotonic_ts_ns: i64,
    #[prost(oneof = "ipc_event::Payload", tags = "10, 11")]
    pub payload: ::core::option::Option<ipc_event::Payload>,
}
/// Nested message and enum types in `IpcEvent`.
pub mod ipc_event {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "10")]
        Log(super::LogEvent),
        #[prost(message, tag = "11")]
        Op(super::OperationEvent),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpcControl {
    #[prost(oneof = "ipc_control::Kind", tags = "1, 2, 3")]
    pub kind: ::core::option::Option<ipc_control::Kind>,
}
/// Nested message and enum types in `IpcControl`.
pub mod ipc_control {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Hello(super::IpcHello),
        #[prost(message, tag = "2")]
        Welcome(super::IpcWelcome),
        #[prost(message, tag = "3")]
        Reject(super::IpcReject),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpcHello {
    /// Security
    ///
    /// required
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    /// Protocol compatibility
    ///
    /// e.g. "1.0"; major must match
    #[prost(string, tag = "2")]
    pub ipc_version: ::prost::alloc::string::String,
    /// requested feature flags (see ยง6)
    #[prost(string, repeated, tag = "3")]
    pub features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Schema & environment
    ///
    /// SHA-256 of FileDescriptorSet (see ยง4)
    #[prost(bytes = "vec", tag = "4")]
    pub schema_hash: ::prost::alloc::vec::Vec<u8>,
    /// absolute path; normalized
    #[prost(string, tag = "5")]
    pub project_root: ::prost::alloc::string::String,
    /// e.g. "unity-mcp-rs"
    #[prost(string, tag = "6")]
    pub client_name: ::prost::alloc::string::String,
    /// semver of Rust server
    #[prost(string, tag = "7")]
    pub client_version: ::prost::alloc::string::String,
    /// optional free-form (OS, arch, etc.)
    #[prost(map = "string, string", tag = "8")]
    pub meta: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpcWelcome {
    /// Echoed/negotiated
    ///
    /// server-supported for this session
    #[prost(string, tag = "1")]
    pub ipc_version: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub accepted_features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// server view of schema
    #[prost(bytes = "vec", tag = "3")]
    pub schema_hash: ::prost::alloc::vec::Vec<u8>,
    /// Server info
    ///
    /// e.g. "unity-editor-bridge"
    #[prost(string, tag = "4")]
    pub server_name: ::prost::alloc::string::String,
    /// plugin/package version
    #[prost(string, tag = "5")]
    pub server_version: ::prost::alloc::string::String,
    /// e.g. "Unity 6000.0.x"
    #[prost(string, tag = "6")]
    pub editor_version: ::prost::alloc::string::String,
    /// UUID for logs and tracing
    #[prost(string, tag = "7")]
    pub session_id: ::prost::alloc::string::String,
    /// optional (platform, license, etc.)
    #[prost(map = "string, string", tag = "8")]
    pub meta: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IpcReject {
    #[prost(enumeration = "ipc_reject::Code", tag = "1")]
    pub code: i32,
    /// single-sentence reason
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `IpcReject`.
pub mod ipc_reject {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        Unauthenticated = 0,
        /// schema mismatch, editor state invalid
        FailedPrecondition = 1,
        /// token valid but insufficient rights
        PermissionDenied = 2,
        /// unsupported major version
        OutOfRange = 3,
        /// unexpected error
        Internal = 4,
        /// editor busy starting up, try later
        Unavailable = 5,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unauthenticated => "UNAUTHENTICATED",
                Self::FailedPrecondition => "FAILED_PRECONDITION",
                Self::PermissionDenied => "PERMISSION_DENIED",
                Self::OutOfRange => "OUT_OF_RANGE",
                Self::Internal => "INTERNAL",
                Self::Unavailable => "UNAVAILABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNAUTHENTICATED" => Some(Self::Unauthenticated),
                "FAILED_PRECONDITION" => Some(Self::FailedPrecondition),
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                "OUT_OF_RANGE" => Some(Self::OutOfRange),
                "INTERNAL" => Some(Self::Internal),
                "UNAVAILABLE" => Some(Self::Unavailable),
                _ => None,
            }
        }
    }
}
