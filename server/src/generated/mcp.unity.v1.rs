// This file is @generated by prost-build.
/// Generic empty placeholder to avoid google.protobuf.Empty at L0.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Empty {}
/// Minimal operation reference for streaming/event demos.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationRef {
    /// opaque identifier
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HealthRequest {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HealthResponse {
    #[prost(bool, tag = "1")]
    pub ready: bool,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// e.g., "OK" - kept for backward compatibility
    #[prost(string, tag = "3")]
    pub status: ::prost::alloc::string::String,
    /// Optional project metadata (one or both may be empty depending on environment)
    ///
    /// e.g., last directory name of project root
    #[prost(string, tag = "4")]
    pub project_name: ::prost::alloc::string::String,
    /// absolute path to Unity project root (parent of Assets)
    #[prost(string, tag = "5")]
    pub project_path: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPlayModeResponse {
    #[prost(bool, tag = "1")]
    pub is_playing: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetPlayModeRequest {
    #[prost(bool, tag = "1")]
    pub play: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetPlayModeResponse {
    #[prost(bool, tag = "1")]
    pub applied: bool,
}
/// Compile diagnostics messages
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCompileDiagnosticsRequest {
    /// Maximum number of diagnostics to return
    #[prost(uint32, tag = "1")]
    pub max_items: u32,
    /// Filter by severity: "all", "error", "warning", "info"
    #[prost(string, tag = "2")]
    pub severity: ::prost::alloc::string::String,
    /// Return only changed diagnostics since last query
    #[prost(bool, tag = "3")]
    pub changed_only: bool,
    /// Filter by assembly name
    #[prost(string, tag = "4")]
    pub assembly: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CompileDiagnostic {
    /// URI of the file containing the diagnostic
    #[prost(string, tag = "1")]
    pub file_uri: ::prost::alloc::string::String,
    /// Location in the file
    #[prost(message, optional, tag = "2")]
    pub range: ::core::option::Option<DiagnosticRange>,
    /// "error", "warning", "info"
    #[prost(string, tag = "3")]
    pub severity: ::prost::alloc::string::String,
    /// Diagnostic message
    #[prost(string, tag = "4")]
    pub message: ::prost::alloc::string::String,
    /// Error code (e.g., "CS0103")
    #[prost(string, tag = "5")]
    pub code: ::prost::alloc::string::String,
    /// Assembly name
    #[prost(string, tag = "6")]
    pub assembly: ::prost::alloc::string::String,
    /// Source system (e.g., "Unity")
    #[prost(string, tag = "7")]
    pub source: ::prost::alloc::string::String,
    /// Unique fingerprint for deduplication
    #[prost(string, tag = "8")]
    pub fingerprint: ::prost::alloc::string::String,
    /// ISO timestamp when first seen
    #[prost(string, tag = "9")]
    pub first_seen: ::prost::alloc::string::String,
    /// ISO timestamp when last seen
    #[prost(string, tag = "10")]
    pub last_seen: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DiagnosticRange {
    /// Line number (0-based)
    #[prost(uint32, tag = "1")]
    pub line: u32,
    /// Column number (0-based)
    #[prost(uint32, tag = "2")]
    pub column: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DiagnosticSummary {
    /// Count of error diagnostics
    #[prost(uint32, tag = "1")]
    pub errors: u32,
    /// Count of warning diagnostics
    #[prost(uint32, tag = "2")]
    pub warnings: u32,
    /// Count of info diagnostics
    #[prost(uint32, tag = "3")]
    pub infos: u32,
    /// List of assemblies with diagnostics
    #[prost(string, repeated, tag = "4")]
    pub assemblies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCompileDiagnosticsResponse {
    /// Whether the request was successful
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// Error message if success is false
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
    /// Unique ID for this compilation
    #[prost(string, tag = "3")]
    pub compile_id: ::prost::alloc::string::String,
    /// Summary statistics
    #[prost(message, optional, tag = "4")]
    pub summary: ::core::option::Option<DiagnosticSummary>,
    /// List of diagnostics
    #[prost(message, repeated, tag = "5")]
    pub diagnostics: ::prost::alloc::vec::Vec<CompileDiagnostic>,
    /// Whether results were truncated due to max_items
    #[prost(bool, tag = "6")]
    pub truncated: bool,
}
/// Import/Export operations for Unity assets
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImportAssetRequest {
    #[prost(string, repeated, tag = "1")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "2")]
    pub recursive: bool,
    #[prost(bool, tag = "3")]
    pub auto_refresh: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImportAssetResult {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub guid: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub ok: bool,
    #[prost(string, tag = "4")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportAssetResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<ImportAssetResult>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MoveAssetRequest {
    #[prost(string, tag = "1")]
    pub from_path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub to_path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MoveAssetResponse {
    #[prost(bool, tag = "1")]
    pub ok: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub new_guid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteAssetRequest {
    #[prost(string, repeated, tag = "1")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "2")]
    pub soft: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteAssetResponse {
    #[prost(string, repeated, tag = "1")]
    pub deleted: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub failed: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RefreshRequest {
    #[prost(bool, tag = "1")]
    pub force: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RefreshResponse {
    #[prost(bool, tag = "1")]
    pub ok: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GuidToPathRequest {
    #[prost(string, repeated, tag = "1")]
    pub guids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuidToPathResponse {
    #[prost(map = "string, string", tag = "1")]
    pub map: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PathToGuidRequest {
    #[prost(string, repeated, tag = "1")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PathToGuidResponse {
    #[prost(map = "string, string", tag = "1")]
    pub map: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AssetsRequest {
    #[prost(oneof = "assets_request::Payload", tags = "1, 2, 3, 4, 5, 6")]
    pub payload: ::core::option::Option<assets_request::Payload>,
}
/// Nested message and enum types in `AssetsRequest`.
pub mod assets_request {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        Import(super::ImportAssetRequest),
        #[prost(message, tag = "2")]
        Move(super::MoveAssetRequest),
        #[prost(message, tag = "3")]
        Delete(super::DeleteAssetRequest),
        #[prost(message, tag = "4")]
        Refresh(super::RefreshRequest),
        #[prost(message, tag = "5")]
        G2p(super::GuidToPathRequest),
        #[prost(message, tag = "6")]
        P2g(super::PathToGuidRequest),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetsResponse {
    /// 0=OK, 2=INVALID_ARGUMENT, 5=NOT_FOUND, 13=INTERNAL
    #[prost(int32, tag = "1")]
    pub status_code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(oneof = "assets_response::Payload", tags = "10, 11, 12, 13, 14, 15")]
    pub payload: ::core::option::Option<assets_response::Payload>,
}
/// Nested message and enum types in `AssetsResponse`.
pub mod assets_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "10")]
        Import(super::ImportAssetResponse),
        #[prost(message, tag = "11")]
        Move(super::MoveAssetResponse),
        #[prost(message, tag = "12")]
        Delete(super::DeleteAssetResponse),
        #[prost(message, tag = "13")]
        Refresh(super::RefreshResponse),
        #[prost(message, tag = "14")]
        G2p(super::GuidToPathResponse),
        #[prost(message, tag = "15")]
        P2g(super::PathToGuidResponse),
    }
}
/// Prefab operations for Unity
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreatePrefabRequest {
    /// Name or path of GameObject in scene
    #[prost(string, tag = "1")]
    pub game_object_path: ::prost::alloc::string::String,
    /// Asset path for the prefab
    #[prost(string, tag = "2")]
    pub prefab_path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreatePrefabResponse {
    #[prost(bool, tag = "1")]
    pub ok: bool,
    #[prost(string, tag = "2")]
    pub guid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdatePrefabRequest {
    /// Name or path of GameObject in scene
    #[prost(string, tag = "1")]
    pub game_object_path: ::prost::alloc::string::String,
    /// Existing prefab asset path
    #[prost(string, tag = "2")]
    pub prefab_path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdatePrefabResponse {
    #[prost(bool, tag = "1")]
    pub ok: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApplyPrefabOverridesRequest {
    /// Name or path of instantiated prefab
    #[prost(string, tag = "1")]
    pub instance_path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApplyPrefabOverridesResponse {
    #[prost(bool, tag = "1")]
    pub ok: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Unified request for prefab operations
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PrefabRequest {
    #[prost(oneof = "prefab_request::Payload", tags = "1, 2, 3")]
    pub payload: ::core::option::Option<prefab_request::Payload>,
}
/// Nested message and enum types in `PrefabRequest`.
pub mod prefab_request {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        Create(super::CreatePrefabRequest),
        #[prost(message, tag = "2")]
        Update(super::UpdatePrefabRequest),
        #[prost(message, tag = "3")]
        ApplyOverrides(super::ApplyPrefabOverridesRequest),
    }
}
/// Unified response for prefab operations
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PrefabResponse {
    /// 0=OK, others follow canonical gRPC codes
    #[prost(int32, tag = "1")]
    pub status_code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(oneof = "prefab_response::Payload", tags = "10, 11, 12")]
    pub payload: ::core::option::Option<prefab_response::Payload>,
}
/// Nested message and enum types in `PrefabResponse`.
pub mod prefab_response {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "10")]
        Create(super::CreatePrefabResponse),
        #[prost(message, tag = "11")]
        Update(super::UpdatePrefabResponse),
        #[prost(message, tag = "12")]
        ApplyOverrides(super::ApplyPrefabOverridesResponse),
    }
}
/// Architecture or variant knobs (optional where relevant)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuildVariants {
    /// e.g., "x86_64", "arm64" (macOS), "universal"
    #[prost(string, tag = "1")]
    pub architecture: ::prost::alloc::string::String,
    /// e.g., \["arm64-v8a","armeabi-v7a"\] (Android)
    #[prost(string, repeated, tag = "2")]
    pub abis: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Development build flag
    #[prost(bool, tag = "3")]
    pub development: bool,
    /// Force IL2CPP if applicable
    #[prost(bool, tag = "4")]
    pub il2cpp: bool,
    /// Strip build
    #[prost(bool, tag = "5")]
    pub strip_symbols: bool,
}
/// Player build request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildPlayerRequest {
    #[prost(enumeration = "BuildPlatform", tag = "1")]
    pub platform: i32,
    /// absolute or project-relative path
    #[prost(string, tag = "2")]
    pub output_path: ::prost::alloc::string::String,
    /// project-relative e.g., "Assets/Scenes/Main.unity"
    #[prost(string, repeated, tag = "3")]
    pub scenes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// arch/abi/dev flags
    #[prost(message, optional, tag = "4")]
    pub variants: ::core::option::Option<BuildVariants>,
    /// scripting define symbols per group
    #[prost(map = "string, string", tag = "5")]
    pub define_symbols: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Player build response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuildPlayerResponse {
    /// 0 OK; nonzero = failure
    #[prost(int32, tag = "1")]
    pub status_code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// final file/dir
    #[prost(string, tag = "3")]
    pub output_path: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub build_time_ms: u64,
    /// if available from report
    #[prost(uint64, tag = "5")]
    pub size_bytes: u64,
    #[prost(string, repeated, tag = "6")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// AssetBundles build request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuildAssetBundlesRequest {
    /// absolute or project-relative
    #[prost(string, tag = "1")]
    pub output_directory: ::prost::alloc::string::String,
    /// BuildAssetBundleOptions.DeterministicAssetBundle
    #[prost(bool, tag = "2")]
    pub deterministic: bool,
    /// ChunkBasedCompression
    #[prost(bool, tag = "3")]
    pub chunk_based: bool,
    /// ForceRebuildAssetBundle
    #[prost(bool, tag = "4")]
    pub force_rebuild: bool,
}
/// AssetBundles build response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuildAssetBundlesResponse {
    #[prost(int32, tag = "1")]
    pub status_code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub output_directory: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub build_time_ms: u64,
}
/// Unified build request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildRequest {
    #[prost(oneof = "build_request::Payload", tags = "1, 2")]
    pub payload: ::core::option::Option<build_request::Payload>,
}
/// Nested message and enum types in `BuildRequest`.
pub mod build_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        Player(super::BuildPlayerRequest),
        #[prost(message, tag = "2")]
        Bundles(super::BuildAssetBundlesRequest),
    }
}
/// Unified build response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuildResponse {
    #[prost(oneof = "build_response::Payload", tags = "1, 2")]
    pub payload: ::core::option::Option<build_response::Payload>,
}
/// Nested message and enum types in `BuildResponse`.
pub mod build_response {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        Player(super::BuildPlayerResponse),
        #[prost(message, tag = "2")]
        Bundles(super::BuildAssetBundlesResponse),
    }
}
/// Supported platforms (subset; extend as needed)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BuildPlatform {
    BpUnspecified = 0,
    BpStandaloneWindows64 = 1,
    /// macOS
    BpStandaloneOsx = 2,
    BpStandaloneLinux64 = 3,
    BpAndroid = 10,
    BpIos = 11,
}
impl BuildPlatform {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BpUnspecified => "BP_UNSPECIFIED",
            Self::BpStandaloneWindows64 => "BP_STANDALONE_WINDOWS64",
            Self::BpStandaloneOsx => "BP_STANDALONE_OSX",
            Self::BpStandaloneLinux64 => "BP_STANDALONE_LINUX64",
            Self::BpAndroid => "BP_ANDROID",
            Self::BpIos => "BP_IOS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BP_UNSPECIFIED" => Some(Self::BpUnspecified),
            "BP_STANDALONE_WINDOWS64" => Some(Self::BpStandaloneWindows64),
            "BP_STANDALONE_OSX" => Some(Self::BpStandaloneOsx),
            "BP_STANDALONE_LINUX64" => Some(Self::BpStandaloneLinux64),
            "BP_ANDROID" => Some(Self::BpAndroid),
            "BP_IOS" => Some(Self::BpIos),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationGetRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationGetResponse {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub state: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationCancelRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationCancelResponse {
    #[prost(bool, tag = "1")]
    pub accepted: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LogEvent {
    /// sender clock
    #[prost(int64, tag = "1")]
    pub monotonic_ts_ns: i64,
    #[prost(enumeration = "log_event::Level", tag = "2")]
    pub level: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    /// e.g., "Unity", "Build", "Assets"
    #[prost(string, tag = "4")]
    pub category: ::prost::alloc::string::String,
    /// optional, compacted
    #[prost(string, tag = "5")]
    pub stack_trace: ::prost::alloc::string::String,
}
/// Nested message and enum types in `LogEvent`.
pub mod log_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Level {
        Trace = 0,
        Debug = 1,
        Info = 2,
        Warn = 3,
        Error = 4,
    }
    impl Level {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Trace => "TRACE",
                Self::Debug => "DEBUG",
                Self::Info => "INFO",
                Self::Warn => "WARN",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRACE" => Some(Self::Trace),
                "DEBUG" => Some(Self::Debug),
                "INFO" => Some(Self::Info),
                "WARN" => Some(Self::Warn),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationEvent {
    /// unique per operation
    #[prost(string, tag = "1")]
    pub op_id: ::prost::alloc::string::String,
    #[prost(enumeration = "operation_event::Kind", tag = "2")]
    pub kind: i32,
    /// 0..100, for PROGRESS/COMPLETE
    #[prost(int32, tag = "3")]
    pub progress: i32,
    /// 0=OK; nonzero=error codes on COMPLETE
    #[prost(int32, tag = "4")]
    pub code: i32,
    /// short human message
    #[prost(string, tag = "5")]
    pub message: ::prost::alloc::string::String,
    /// optional structured data
    #[prost(string, tag = "6")]
    pub payload_json: ::prost::alloc::string::String,
}
/// Nested message and enum types in `OperationEvent`.
pub mod operation_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        Start = 0,
        Progress = 1,
        Complete = 2,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Start => "START",
                Self::Progress => "PROGRESS",
                Self::Complete => "COMPLETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "START" => Some(Self::Start),
                "PROGRESS" => Some(Self::Progress),
                "COMPLETE" => Some(Self::Complete),
                _ => None,
            }
        }
    }
}
/// Top-level envelope for all IPC messages
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpcEnvelope {
    /// Empty for handshake messages
    #[prost(string, tag = "1")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(oneof = "ipc_envelope::Kind", tags = "2, 3, 4")]
    pub kind: ::core::option::Option<ipc_envelope::Kind>,
}
/// Nested message and enum types in `IpcEnvelope`.
pub mod ipc_envelope {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "2")]
        Request(super::IpcRequest),
        #[prost(message, tag = "3")]
        Response(super::IpcResponse),
        #[prost(message, tag = "4")]
        Event(super::IpcEvent),
    }
}
/// Request message with typed payloads
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpcRequest {
    #[prost(oneof = "ipc_request::Payload", tags = "1, 10, 11, 12, 20, 21, 30, 40, 41")]
    pub payload: ::core::option::Option<ipc_request::Payload>,
}
/// Nested message and enum types in `IpcRequest`.
pub mod ipc_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// Health check
        #[prost(message, tag = "1")]
        Health(super::HealthRequest),
        /// Editor control
        #[prost(message, tag = "10")]
        GetPlayMode(super::Empty),
        #[prost(message, tag = "11")]
        SetPlayMode(super::SetPlayModeRequest),
        #[prost(message, tag = "12")]
        GetCompileDiagnostics(super::GetCompileDiagnosticsRequest),
        /// Assets
        #[prost(message, tag = "20")]
        Assets(super::AssetsRequest),
        /// Prefab
        #[prost(message, tag = "21")]
        Prefab(super::PrefabRequest),
        /// Build
        #[prost(message, tag = "30")]
        Build(super::BuildRequest),
        /// Operations
        #[prost(message, tag = "40")]
        OperationGet(super::OperationGetRequest),
        #[prost(message, tag = "41")]
        OperationCancel(super::OperationCancelRequest),
    }
}
/// Response message with typed payloads
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpcResponse {
    /// Matches the request correlation_id
    #[prost(string, tag = "1")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(oneof = "ipc_response::Payload", tags = "2, 10, 11, 12, 20, 21, 30, 40, 41")]
    pub payload: ::core::option::Option<ipc_response::Payload>,
}
/// Nested message and enum types in `IpcResponse`.
pub mod ipc_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// Health check
        #[prost(message, tag = "2")]
        Health(super::HealthResponse),
        /// Editor control
        #[prost(message, tag = "10")]
        GetPlayMode(super::GetPlayModeResponse),
        #[prost(message, tag = "11")]
        SetPlayMode(super::SetPlayModeResponse),
        #[prost(message, tag = "12")]
        GetCompileDiagnostics(super::GetCompileDiagnosticsResponse),
        /// Assets
        #[prost(message, tag = "20")]
        Assets(super::AssetsResponse),
        /// Prefab
        #[prost(message, tag = "21")]
        Prefab(super::PrefabResponse),
        /// Build
        #[prost(message, tag = "30")]
        Build(super::BuildResponse),
        /// Operations
        #[prost(message, tag = "40")]
        OperationGet(super::OperationGetResponse),
        #[prost(message, tag = "41")]
        OperationCancel(super::OperationCancelResponse),
    }
}
/// Event message for server-to-client notifications
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IpcEvent {
    #[prost(int64, tag = "1")]
    pub monotonic_ts_ns: i64,
    #[prost(oneof = "ipc_event::Payload", tags = "10, 11")]
    pub payload: ::core::option::Option<ipc_event::Payload>,
}
/// Nested message and enum types in `IpcEvent`.
pub mod ipc_event {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "10")]
        Log(super::LogEvent),
        #[prost(message, tag = "11")]
        Op(super::OperationEvent),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpcControl {
    #[prost(oneof = "ipc_control::Kind", tags = "1, 2, 3")]
    pub kind: ::core::option::Option<ipc_control::Kind>,
}
/// Nested message and enum types in `IpcControl`.
pub mod ipc_control {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Hello(super::IpcHello),
        #[prost(message, tag = "2")]
        Welcome(super::IpcWelcome),
        #[prost(message, tag = "3")]
        Reject(super::IpcReject),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpcHello {
    /// Security
    ///
    /// required
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    /// Protocol compatibility
    ///
    /// e.g. "1.0"; major must match
    #[prost(string, tag = "2")]
    pub ipc_version: ::prost::alloc::string::String,
    /// requested feature flags (see §6)
    #[prost(string, repeated, tag = "3")]
    pub features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Schema & environment
    ///
    /// SHA-256 of FileDescriptorSet (see §4)
    #[prost(bytes = "vec", tag = "4")]
    pub schema_hash: ::prost::alloc::vec::Vec<u8>,
    /// e.g. "unity-mcp-rs"
    #[prost(string, tag = "6")]
    pub client_name: ::prost::alloc::string::String,
    /// semver of Rust server
    #[prost(string, tag = "7")]
    pub client_version: ::prost::alloc::string::String,
    /// Optional free-form client environment metadata (OS, arch, etc.).
    /// Clients may include additional context here if needed.
    #[prost(map = "string, string", tag = "8")]
    pub meta: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpcWelcome {
    /// Echoed/negotiated
    ///
    /// server-supported for this session
    #[prost(string, tag = "1")]
    pub ipc_version: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub accepted_features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// server view of schema
    #[prost(bytes = "vec", tag = "3")]
    pub schema_hash: ::prost::alloc::vec::Vec<u8>,
    /// Server info
    ///
    /// e.g. "unity-editor-bridge"
    #[prost(string, tag = "4")]
    pub server_name: ::prost::alloc::string::String,
    /// plugin/package version
    #[prost(string, tag = "5")]
    pub server_version: ::prost::alloc::string::String,
    /// e.g. "Unity 6000.0.x"
    #[prost(string, tag = "6")]
    pub editor_version: ::prost::alloc::string::String,
    /// UUID for logs and tracing
    #[prost(string, tag = "7")]
    pub session_id: ::prost::alloc::string::String,
    /// optional (platform, license, etc.)
    #[prost(map = "string, string", tag = "8")]
    pub meta: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IpcReject {
    #[prost(enumeration = "ipc_reject::Code", tag = "1")]
    pub code: i32,
    /// single-sentence reason
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `IpcReject`.
pub mod ipc_reject {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        Unauthenticated = 0,
        /// schema mismatch, editor state invalid
        FailedPrecondition = 1,
        /// token valid but insufficient rights
        PermissionDenied = 2,
        /// unsupported major version
        OutOfRange = 3,
        /// unexpected error
        Internal = 4,
        /// editor busy starting up, try later
        Unavailable = 5,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unauthenticated => "UNAUTHENTICATED",
                Self::FailedPrecondition => "FAILED_PRECONDITION",
                Self::PermissionDenied => "PERMISSION_DENIED",
                Self::OutOfRange => "OUT_OF_RANGE",
                Self::Internal => "INTERNAL",
                Self::Unavailable => "UNAVAILABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNAUTHENTICATED" => Some(Self::Unauthenticated),
                "FAILED_PRECONDITION" => Some(Self::FailedPrecondition),
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                "OUT_OF_RANGE" => Some(Self::OutOfRange),
                "INTERNAL" => Some(Self::Internal),
                "UNAVAILABLE" => Some(Self::Unavailable),
                _ => None,
            }
        }
    }
}
/// Test execution request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RunTestsRequest {
    /// Unique run identifier
    #[prost(string, tag = "1")]
    pub run_id: ::prost::alloc::string::String,
    /// Test mode: edit, play, or all
    #[prost(enumeration = "TestMode", tag = "2")]
    pub mode: i32,
    /// Optional test name filter
    #[prost(string, optional, tag = "3")]
    pub test_filter: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional category filters
    #[prost(string, repeated, tag = "4")]
    pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Timeout in seconds (default: 180)
    #[prost(uint32, tag = "5")]
    pub timeout_sec: u32,
    /// Max results to return (default: 2000)
    #[prost(uint32, tag = "6")]
    pub max_items: u32,
    /// Include passed tests in results (default: true)
    #[prost(bool, tag = "7")]
    pub include_passed: bool,
}
/// Test execution response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RunTestsResponse {
    /// Echo of run_id from request
    #[prost(string, tag = "1")]
    pub run_id: ::prost::alloc::string::String,
    /// Whether test run was accepted/started
    #[prost(bool, tag = "2")]
    pub accepted: bool,
    /// Status or error message
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
/// Test results request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTestResultsRequest {
    /// Specific run ID (optional, gets latest if not specified)
    #[prost(string, optional, tag = "1")]
    pub run_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Max results to return (default: 2000)
    #[prost(uint32, tag = "2")]
    pub max_items: u32,
    /// Include passed tests (default: true)
    #[prost(bool, tag = "3")]
    pub include_passed: bool,
}
/// Test results response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTestResultsResponse {
    /// Complete test results
    #[prost(message, optional, tag = "1")]
    pub results: ::core::option::Option<TestResults>,
    /// Whether results were found
    #[prost(bool, tag = "2")]
    pub found: bool,
}
/// Test run status request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTestRunStatusRequest {
    /// Specific run ID (optional, gets latest if not specified)
    #[prost(string, optional, tag = "1")]
    pub run_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Test run status response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTestRunStatusResponse {
    /// Current status
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<TestRunStatus>,
    /// Whether status was found
    #[prost(bool, tag = "2")]
    pub found: bool,
}
/// Complete test results structure
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestResults {
    /// Run identifier
    #[prost(string, tag = "1")]
    pub run_id: ::prost::alloc::string::String,
    /// ISO 8601 timestamp
    #[prost(string, tag = "2")]
    pub started_at: ::prost::alloc::string::String,
    /// ISO 8601 timestamp
    #[prost(string, tag = "3")]
    pub finished_at: ::prost::alloc::string::String,
    /// Test mode used
    #[prost(enumeration = "TestMode", tag = "4")]
    pub mode: i32,
    /// Test filter used
    #[prost(string, optional, tag = "5")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    /// Categories used
    #[prost(string, repeated, tag = "6")]
    pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Test summary statistics
    #[prost(message, optional, tag = "7")]
    pub summary: ::core::option::Option<TestSummary>,
    /// Individual test results
    #[prost(message, repeated, tag = "8")]
    pub tests: ::prost::alloc::vec::Vec<TestResult>,
    /// Whether results were truncated
    #[prost(bool, tag = "9")]
    pub truncated: bool,
}
/// Test summary statistics
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TestSummary {
    /// Total tests
    #[prost(uint32, tag = "1")]
    pub total: u32,
    /// Passed tests
    #[prost(uint32, tag = "2")]
    pub passed: u32,
    /// Failed tests
    #[prost(uint32, tag = "3")]
    pub failed: u32,
    /// Skipped tests
    #[prost(uint32, tag = "4")]
    pub skipped: u32,
    /// Total duration in seconds
    #[prost(float, tag = "5")]
    pub duration_sec: f32,
}
/// Individual test result
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestResult {
    /// Assembly name
    #[prost(string, tag = "1")]
    pub assembly: ::prost::alloc::string::String,
    /// Test suite name
    #[prost(string, tag = "2")]
    pub suite: ::prost::alloc::string::String,
    /// Test name
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Full test name
    #[prost(string, tag = "4")]
    pub full_name: ::prost::alloc::string::String,
    /// Test execution status
    #[prost(enumeration = "TestStatus", tag = "5")]
    pub status: i32,
    /// Test duration in seconds
    #[prost(float, tag = "6")]
    pub duration_sec: f32,
    /// Test message (empty if passed)
    #[prost(string, tag = "7")]
    pub message: ::prost::alloc::string::String,
    /// Stack trace (empty if passed)
    #[prost(string, tag = "8")]
    pub stack_trace: ::prost::alloc::string::String,
    /// Test categories
    #[prost(string, repeated, tag = "9")]
    pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Test owner (usually empty)
    #[prost(string, tag = "10")]
    pub owner: ::prost::alloc::string::String,
    /// Source file path
    #[prost(string, tag = "11")]
    pub file: ::prost::alloc::string::String,
    /// Source line number
    #[prost(uint32, tag = "12")]
    pub line: u32,
}
/// Test run status information
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TestRunStatus {
    /// Current run status
    #[prost(enumeration = "RunStatus", tag = "1")]
    pub status: i32,
    /// Run identifier
    #[prost(string, tag = "2")]
    pub run_id: ::prost::alloc::string::String,
    /// Status timestamp (ISO 8601)
    #[prost(string, tag = "3")]
    pub timestamp: ::prost::alloc::string::String,
}
/// Test execution mode enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TestMode {
    Unspecified = 0,
    /// EditMode tests only
    Edit = 1,
    /// PlayMode tests only
    Play = 2,
    /// Both EditMode and PlayMode
    All = 3,
}
impl TestMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TEST_MODE_UNSPECIFIED",
            Self::Edit => "TEST_MODE_EDIT",
            Self::Play => "TEST_MODE_PLAY",
            Self::All => "TEST_MODE_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TEST_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "TEST_MODE_EDIT" => Some(Self::Edit),
            "TEST_MODE_PLAY" => Some(Self::Play),
            "TEST_MODE_ALL" => Some(Self::All),
            _ => None,
        }
    }
}
/// Test execution status enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TestStatus {
    Unspecified = 0,
    /// Test passed
    Passed = 1,
    /// Test failed
    Failed = 2,
    /// Test skipped
    Skipped = 3,
    /// Test inconclusive
    Inconclusive = 4,
}
impl TestStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TEST_STATUS_UNSPECIFIED",
            Self::Passed => "TEST_STATUS_PASSED",
            Self::Failed => "TEST_STATUS_FAILED",
            Self::Skipped => "TEST_STATUS_SKIPPED",
            Self::Inconclusive => "TEST_STATUS_INCONCLUSIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TEST_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "TEST_STATUS_PASSED" => Some(Self::Passed),
            "TEST_STATUS_FAILED" => Some(Self::Failed),
            "TEST_STATUS_SKIPPED" => Some(Self::Skipped),
            "TEST_STATUS_INCONCLUSIVE" => Some(Self::Inconclusive),
            _ => None,
        }
    }
}
/// Test run status enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RunStatus {
    Unspecified = 0,
    /// Test run started
    Started = 1,
    /// Test run in progress
    Running = 2,
    /// Test run completed
    Finished = 3,
    /// Test run failed to start/execute
    Failed = 4,
}
impl RunStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RUN_STATUS_UNSPECIFIED",
            Self::Started => "RUN_STATUS_STARTED",
            Self::Running => "RUN_STATUS_RUNNING",
            Self::Finished => "RUN_STATUS_FINISHED",
            Self::Failed => "RUN_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RUN_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "RUN_STATUS_STARTED" => Some(Self::Started),
            "RUN_STATUS_RUNNING" => Some(Self::Running),
            "RUN_STATUS_FINISHED" => Some(Self::Finished),
            "RUN_STATUS_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
