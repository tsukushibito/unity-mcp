# フェーズA — ハンドシェイク不変条件（詳細作業書）

## 概要
- 目的: Handshakeの不変条件を確立し、スキーマ整合と認証必須を保証する。
- スコープ: スキーマハッシュ検証、トークン必須ポリシー、関連テストと最小ドキュメント。
- 非スコープ: トークン設定UIの本格実装（任意・後回し可）、再接続仕上げ。
- 対応する計画項目: `mvp_work_plan_direct_ipc_v1.md` の フェーズA（A1/A2）

## レビュー合意ポイント（実装前に確定）
- スキーマ不変条件: `IpcHello.schema_hash` 一致必須。サーバーは不一致時に`FAILED_PRECONDITION`。
- トークン方針: Unityは`EditorUserSettings`のみをソース。未設定/空は`UNAUTHENTICATED`。
- SSoT/生成・管理: Rustの`SCHEMA_HASH`（[u8;32]）を唯一のSOTとし、C#側`SCHEMA_HASH_HEX`は事前生成してリポジトリにコミット。CIはパリティチェックで不整合を検出。
- ログ/ガイダンス: 1行で原因と対処（「C#定数再生成」「EditorUserSettingsでMCP.IpcToken設定」）を出す。

## 前提/依存
- 直IPC/TCP接続の基本機構は既存実装を利用（bridgeのEditorDispatcher含む）。
- Rust側の`SCHEMA_HASH`の出力元は単一SOT（`server/src/generated/schema_hash.rs`）。
- C# `SCHEMA_HASH_HEX` は生成スクリプトで更新し、コミットする運用。
- Unity側ビルド環境が開発機に存在し、EditModeテストが実行可能。

## 作業項目一覧

### A1: スキーマハッシュ検証（Unity側）
- A1-1: Rust `SCHEMA_HASH_HEX` の算出・出力箇所の確認と短い設計メモ作成
  - 変更箇所: `server/`（確認のみ、必要なら`docs/`にメモ）
  - 出力物: 設計メモ（算出方法・出力先・更新契機）
  - DoD: 算出・出力の単一経路を明文化
- A1-2: C# `SCHEMA_HASH` の事前生成と配置（Git管理）
  - 変更箇所: `bridge/Assets/**`（生成ファイル置き場）、生成スクリプト/CIワークフロー
  - 出力物: `SCHEMA_HASH_HEX` 定数（生成C#ファイル、Generatedヘッダー付き）
  - DoD: 手動編集禁止。生成スクリプト実行でRustと常に一致し、生成物はコミット対象
- A1-3: Unity側Handshakeでハッシュ一致検証を実装（不一致→`FAILED_PRECONDITION`）
  - 変更箇所: `bridge/Assets/**`（Handshake実装部）
  - DoD: 不一致時に失敗、ログに対処（C#定数再生成）の1行ガイダンス
- A1-4: Rust統合テスト追加（不一致→SchemaMismatch）
  - 変更箇所: `server/tests/**`
  - DoD: 不一致ケースのレッド→修正後グリーンを確認

### A2: トークン必須（No Dev Mode）
- A2-1: トークン取得をEditorUserSettingsに一本化（Env/EditorPrefsを無効化）
  - 変更箇所: `bridge/Assets/**`
  - DoD: 取得経路がEditorUserSettingsのみであることをコード上で明確化
- A2-2: 未設定/空トークンを`UNAUTHENTICATED`でReject（設定方法を簡潔に案内）
  - 変更箇所: `server/src/**`（エラー返却）、`bridge/Assets/**`（文言・ログ）
  - DoD: 期待トークン未設定でも必ずReject。ログに設定手順の1行案内
- A2-3: （任意）SettingsProviderによる簡易設定UIの検討とTODO化
  - 出力物: TODOチケットまたは`tasks/`メモ
  - DoD: 後回しの理由と最小仕様を記録

## 手順（実装の流れ）
1. A1-1でRustのハッシュSOTを確認し、BフェーズのSSoT化の前提を明文化
2. A1-2でC#の`SCHEMA_HASH`生成CIを追加し、自動生成C#を配置
3. A1-3でHandshakeにハッシュ検証を実装。不一致時のエラーハンドリングとログ整備
4. A1-4のRust統合テストで不一致ケースを追加し、検証
5. A2-1でEditorUserSettingsのみを読むようUnity側取得ロジックを整理
6. A2-2で未設定時の`UNAUTHENTICATED`応答とガイダンス文面を統一
7. A2-3は必要に応じてTODO化

## 具体仕様（定数・パス・生成物）
- Rust側SSoT
  - 定義: `server/src/generated/schema_hash.rs` に `pub const SCHEMA_HASH: [u8; 32];`
  - 生成: `server/scripts/generate-rust-proto.sh` が生成し、`server/src/lib.rs` から `include!("generated/schema_hash.rs");`
  - 利用: `server/src/ipc/codec.rs::schema_hash() -> Vec<u8>` が Hello に設定（`pb::IpcHello.schema_hash`）
- C#生成物（事前生成してコミット）
  - 出力先（確定案）: `bridge/Packages/com.example.mcp-bridge/Editor/Generated/SchemaHash.cs`
  - 内容（提案インターフェイス）:
    - `// <auto-generated> DO NOT EDIT. Generated from server SCHEMA_HASH.`
    - `namespace Mcp.Unity.V1.Generated;`
    - `internal static class Schema { public const string SCHEMA_HASH_HEX = "<64桁hex>"; }`
    - 必要に応じ `public static byte[] SchemaHashBytes`（HEX→bytes変換）を同クラスに実装
  - 生成元: Rustの`SCHEMA_HASH`からHEX化した文字列（32バイト→64桁）
  - 管理: 生成スクリプトで更新し、コミット。CIはRust↔C#のパリティチェックのみ実施

### A1-2 生成フロー仕様（詳細）
- 生成スクリプト（確定案）
  - ファイル: `bridge/Tools/generate-csharp.sh`（既存）に「SchemaHash.cs生成」を追加
  - 役割: 以下を実行
    - C#: `--csharp_out` によるメッセージ生成（既存）
    - Rust SOTからのHEX取得: `server/src/generated/schema_hash.rs` の `SCHEMA_HASH` を読み取り、HEXへ整形
      - 代替: `server/src/generated/schema.pb` のSHA-256を再計算（Protoc一致が前提）
    - C#: `bridge/Packages/com.example.mcp-bridge/Editor/Generated/SchemaHash.cs` をテンプレートで出力
  - 冪等性: 実行前後で内容に差分が無ければ変更なし（exit 0）
- C#テンプレート（雛形）
  - 先頭コメント: `// <auto-generated> DO NOT EDIT. Generated from server SCHEMA_HASH.`
  - 名前空間/型: `namespace Mcp.Unity.V1.Generated; internal static class Schema { public const string SCHEMA_HASH_HEX = "<HEX>"; }`
- 失敗時の扱い
  - Rust生成物未更新でも、`SCHEMA_HASH`抽出に失敗した場合は非0終了
  - 出力先ディレクトリが無ければ作成（スクリプト内処理）
- 開発者フロー（手動）
  - `cd bridge && ./Tools/generate-csharp.sh`
  - 差分確認→コミット→PR
  - CIは後述のパリティ検証でドリフト検出
- トークン取得（Unity Editorのみ）
  - ソース: `UnityEditor.EditorUserSettings.GetConfigValue("MCP.IpcToken")`
  - 無効化: 環境変数 `MCP_IPC_TOKEN` と `EditorPrefs` は参照しない（明示的に無視）
- エラーコードと文面（提案）
  - 未認証: `UNAUTHENTICATED` / `Missing or empty token. Set EditorUserSettings: MCP.IpcToken`
  - スキーマ不一致: `FAILED_PRECONDITION` / `Schema hash mismatch. Regenerate C# SCHEMA_HASH from server (CI).`

## 実装ポイント（参照コード・場所）
- Hello送信箇所（Rust側）: `server/src/ipc/client.rs` の `pb::IpcHello { schema_hash: codec::schema_hash(), ... }`
- 生成物の存在（Rust）: `server/src/generated/schema_hash.rs`（SOT）
- Unity側ハンドシェイク実装箇所: `bridge/Assets/**` のIPCクライアント層（該当スクリプトに検証を追加）

## 受け入れ条件（DoD）
- ハッシュ不一致時にUnityが`FAILED_PRECONDITION`を返し、ログには対処が1行で示される
- Rust統合テストに不一致ケースが追加され、正常/異常が判別できる
- トークン未設定/空で必ず`UNAUTHENTICATED`。Unity側ログに設定手順が出力される
- トークン取得経路はEditorUserSettingsのみ（Env/EditorPrefsは無視）

## テスト
- 自動: `server/tests/**` 統合テスト（schema mismatch, tokenなし）
- 自動: Unity EditModeテスト（トークン必須、ハッピーパス確認）
- 手動: 一時的にC# `SCHEMA_HASH`を改変して不一致を再現、期待エラーを確認

## リスク/ロールバック
- ハッシュ生成の不整合: CIの生成ステップで検出し、PRをブロック
- トークン経路切替による既存環境の混乱: Quickstart/ログに明示、否定テストで回避

## 監査ログ
- PRリンク、CI実行結果、テスト結果スクリーンショット（必要に応じて）

## 参照
- `tasks/mvp_work_plan_direct_ipc_v1.md` フェーズA
- `tasks/mvp_worklist_checklist.md`

## チェックリストID（対応付け）
- A1-1, A1-2, A1-3, A1-4 / A2-1, A2-2, A2-3 を `tasks/mvp_worklist_checklist.md` の該当行に併記（レビュー後に反映）
